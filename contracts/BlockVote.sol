// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title BlockVote
 * @dev A decentralized voting contract to manage multiple proposals with multiple candidates.
 * This contract is designed to be the on-chain counterpart for the AbstractVote application.
 */
contract BlockVote {
    address public owner;

    enum ProposalStatus { Pending, Active, Closed }

    struct Candidate {
        string name;
        uint voteCount;
    }

    struct Proposal {
        uint id;
        string title;
        string description;
        ProposalStatus status;
        uint endTime;
        Candidate[] candidates;
        mapping(address => bool) hasVoted;
        string zkpConfiguration; // Placeholder for ZKP integration details
    }

    Proposal[] public proposals;
    uint public proposalCounter;

    event ProposalCreated(uint indexed proposalId, string title, address indexed creator);
    event ProposalStatusUpdated(uint indexed proposalId, ProposalStatus newStatus);
    event Voted(uint indexed proposalId, uint indexed candidateId, address indexed voter);

    modifier onlyOwner() {
        require(msg.sender == owner, "BlockVote: Caller is not the owner");
        _;
    }

    constructor() {
        owner = msg.sender;
    }

    /**
     * @dev Creates a new proposal. Restricted to the contract owner (admin).
     * @param _title The title of the proposal.
     * @param _description A detailed description of the proposal.
     * @param _candidateNames An array of strings representing the candidate names.
     * @param _zkpConfiguration A string to store ZKP-related configuration, as generated by the app's AI.
     */
    function createProposal(
        string memory _title,
        string memory _description,
        string[] memory _candidateNames,
        string memory _zkpConfiguration
    ) public onlyOwner {
        require(_candidateNames.length >= 2, "BlockVote: Must have at least two candidates");

        uint proposalId = proposalCounter;
        proposals.push(); // Create a new empty proposal struct in storage
        Proposal storage newProposal = proposals[proposalId];

        newProposal.id = proposalId;
        newProposal.title = _title;
        newProposal.description = _description;
        newProposal.status = ProposalStatus.Pending;
        newProposal.zkpConfiguration = _zkpConfiguration;

        for (uint i = 0; i < _candidateNames.length; i++) {
            newProposal.candidates.push(Candidate({
                name: _candidateNames[i],
                voteCount: 0
            }));
        }

        proposalCounter++;
        emit ProposalCreated(proposalId, _title, msg.sender);
    }

    /**
     * @dev Starts a voting period for a pending proposal.
     * @param _proposalId The ID of the proposal to activate.
     * @param _durationDays The duration of the voting period in days.
     */
    function startProposal(uint _proposalId, uint _durationDays) public onlyOwner {
        Proposal storage p = proposals[_proposalId];
        require(p.status == ProposalStatus.Pending, "BlockVote: Proposal not in pending state");
        require(_durationDays > 0, "BlockVote: Duration must be greater than 0");

        p.status = ProposalStatus.Active;
        p.endTime = block.timestamp + (_durationDays * 1 days);

        emit ProposalStatusUpdated(_proposalId, ProposalStatus.Active);
    }

    /**
     * @dev Manually closes a voting period for an active proposal.
     * @param _proposalId The ID of the proposal to close.
     */
    function closeProposal(uint _proposalId) public onlyOwner {
        Proposal storage p = proposals[_proposalId];
        require(p.status == ProposalStatus.Active, "BlockVote: Proposal not active");
        
        p.status = ProposalStatus.Closed;
        // The endTime is kept for historical reference
        
        emit ProposalStatusUpdated(_proposalId, ProposalStatus.Closed);
    }

    /**
     * @dev Casts a vote on an active proposal.
     * @param _proposalId The ID of the proposal to vote on.
     * @param _candidateId The index of the candidate to vote for.
     */
    function vote(uint _proposalId, uint _candidateId) public {
        Proposal storage p = proposals[_proposalId];

        // Automatically close proposal if voting period has ended
        if (block.timestamp > p.endTime && p.status == ProposalStatus.Active) {
            p.status = ProposalStatus.Closed;
            emit ProposalStatusUpdated(_proposalId, ProposalStatus.Closed);
        }

        require(p.status == ProposalStatus.Active, "BlockVote: Proposal is not active");
        require(!p.hasVoted[msg.sender], "BlockVote: Already voted on this proposal");
        require(_candidateId < p.candidates.length, "BlockVote: Invalid candidate ID");

        p.hasVoted[msg.sender] = true;
        p.candidates[_candidateId].voteCount++;

        emit Voted(_proposalId, _candidateId, msg.sender);
    }

    /**
     * @dev Returns the details of a specific proposal.
     * @param _proposalId The ID of the proposal.
     */
    function getProposal(uint _proposalId) public view returns (
        uint id,
        string memory title,
        ProposalStatus status,
        uint endTime,
        uint candidateCount
    ) {
        Proposal storage p = proposals[_proposalId];
        return (p.id, p.title, p.status, p.endTime, p.candidates.length);
    }

    /**
     * @dev Returns the results for a specific proposal.
     * @param _proposalId The ID of the proposal.
     */
    function getProposalResults(uint _proposalId) public view returns (Candidate[] memory) {
        return proposals[_proposalId].candidates;
    }

    /**
     * @dev Returns the total number of proposals created.
     */
    function getProposalCount() public view returns (uint) {
        return proposalCounter;
    }
}